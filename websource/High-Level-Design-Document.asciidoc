= Introduction

== Document Scope/Purpose

[quote,'http://webcache.googleusercontent.com/search?q=cache:1rTEwgpQg5UJ:https://www.cs.purdue.edu/homes/cs307/ExampleDocs/DesignTemplate_Fall08.doc+&cd=2&hl=en&ct=clnk&gl=us[Perdue Design Template]']
____
Here you should describe what the purpose of this document is, and what it is not (e.g. it does not describe how a user uses the system.)  No-one likes to have to read a few pages to figure out if they're looking at the right document.
____

[quote,'http://en.wikipedia.org/wiki/High-level_design[High Level Design on Wikipedia]']
____
High-level design provides an overview of an entire system, identifying all its elements at some level of abstraction. This contrasts with Low level Design which exposes the detailed design of each of these elements.
____

This document ("High Level Design Document") serves the following purposes:

  * Translating the requirements therein link:Game-Design-Document[] into general-purpose requirements that suits the mission, particularities, and requirements of Hypatia Engine
  * To enumerate all of the features and requirements of Hypatia Engine
  * This document will be used as a model for the Hypatia Engine Api Document (or _documents_). The API Document is written before the code.
  * This document will describe the complex data models and techniques required, i.e., architectures, that are features of this system
  * Hypatia Engine will be the game engine used in the Hypatia game, which will also double as a demo for Hypatia Engine

== Intended Audience

[quote,'http://webcache.googleusercontent.com/search?q=cache:1rTEwgpQg5UJ:https://www.cs.purdue.edu/homes/cs307/ExampleDocs/DesignTemplate_Fall08.doc+&cd=2&hl=en&ct=clnk&gl=us[Perdue Design Template]']
____
This section should describe the stakeholders you are targeting this document at.  This is another way to let people quickly discover whether they're reading the wrong document.
____

Hypatia Engine is for everyone, no strings attached. Hypatia Engine is a permissively licensed contribution to society, aimed to be highly accessible for users of any platform. Because of this philosophy, Hypatia Engine must ensure:

  * Functionality across operating systems (priority in respective order): FreeBSD, Android, Other Linux, Mac, and Windows
  * Superb documentation and lessons
  * Python 2.7.x and Python 3.x

More specifically, Hypatia Engine is aimed at:

  * People who desire to create a 2D sprite and tile based game, which calls back to old console games, but with modern capabilities
  * People who want to use Hypatia Engine in inventive ways
  * Ourselves, as it will be used for making Hypatia the game. Which also doubles as our demo for Hypatia Engine.
  * Seasoned programmers, novice programmers alike
  * Seasoned gamedevs, novice gamedevs alike
  * Learners in general
  * Primarily people who want to create 2D top-down action RPGs, e.g., _Zelda: Oracle of Ages_, _Zelda: Oracle of Seasons_, _Land of Ys_, _Yume Nikki_, and _Crystalis_

== Overview

[quote,'http://webcache.googleusercontent.com/search?q=cache:1rTEwgpQg5UJ:https://www.cs.purdue.edu/homes/cs307/ExampleDocs/DesignTemplate_Fall08.doc+&cd=2&hl=en&ct=clnk&gl=us[Perdue Design Template]']
____
What is it that you're building? Cross references or links to other documents may be relevant. This is a non-technical overview to provide the right context for understanding the following technical sections.
____

Hypatia Engine is a 2D game engine. Hypatia Engine is primarily for creating 2D top-down action RPGs. The project was started with _Zelda: Oracle of Ages_, _Zelda: Oracle of Seasons_, _Land of Ys_, _Yume Nikki_, and _Crystalis_ in mind. It will also be used to create the _Hypatia Game_.

Hypatia Engine is supposed to nostalgically emulate the experience of older console/handheld top-down 2D action RPGs, without any of the old restrictions. Hypatia Engine is meant to be exceeding simple, to both a programming developer through the Python API or through the suite of GUI-oriented tools which used the aformentioned API, for the layuser.

=== Advantages

Hypatia Engine has advantages over other game engine systems because it is specifically streamlined for a particular style of gameplay. It is also coupled with an official game as a great example of its capabilities. Hypatia Engine will be thoroughly documented, with lots of tutorials/videos/wiki articles, etc.

== Design Goals (Goals and Guidelines)

[quote,'http://webcache.googleusercontent.com/search?q=cache:1rTEwgpQg5UJ:https://www.cs.purdue.edu/homes/cs307/ExampleDocs/DesignTemplate_Fall08.doc+&cd=2&hl=en&ct=clnk&gl=us[Perdue Design Template]']
____
You may adopt either of these two formats:

  * Describe the goals and guiding principles ("philosophy") used to design the software, and that affect the architecture and high-level design. Describe the reason for their desirability (if possible, in relation to requirements), unless they are trivially obvious.
  * Identify the software requirements and objectives that have a significant impact on the architecture, for example as a bullet list of single line items.
____

[quote,'http://www.bitformation.com/art/sample_sw_design_doc.html[bitInformation Consulting - Sample Software Design Document]']
____
This section should outline the technical manifestation of the system requirements, and list the goals your design is intended to achieve. 
____

Some aspects and terminology are borrowed from link:http://rpg.hamsterrepublic.com/ohrrpgce/Main_Page[OHRRPGCE].

Hypatia Engine is a 2D adventure game engine. Hypatia Engine can be used entirely as a framework, but it also has helpful applications for building a Hypatia Engine project.

Hypatia Engine consists of the following components (if an item links to a wiki page, it means it's completed, or with notes):

  * User Interface

    ** Menus
    ** Settings

      *** Video: fullscreen/windowed
      *** Audio
      *** Input: joystick and key config

    ** Gameplay
    ** Battle

  * Renderer

    ** Camera (currently is "viewport")

      *** Follows human player in center, adjusts when coming to corners and edges of map
      *** Better camera control; needs diagonal movement rounding/euclidean movment, should be solved through DirectionalVelocity, though (see physics section), specifically there is no camera jitter going northeast because in a four DirectionalVelecity system the camera moves up one pixel, then to the east one pixel, whereas with an EightDirectionalVelecity system you can simply move northeast one pixel if diagonal is being triggered.

    ** Filter
    ** Full screen
    ** Windowed
    ** Arbitrary resolutions
    ** Automatic surface conversions (pygame efficiency) and caching?

  * Physics

    ** DirectionalVelecity: 2D directional velocity, 8 directions.
    ** Particle physics

  * Effects

    ** Simple lighting

  * Audio management
    
    ** Music

      *** Dynamic, context music

    ** Sound Effects

      *** Environment
      *** Voices: meepspeak/synth voices

  * Resource manager

    ** Scans resources to check for changes, if so regens or clears necessary caches, otherwise previous caches are used
    ** Automatic surface conversions (pygame efficiency) are chached

  * Texture management

    ** Fonts/text
    ** Sprites

      *** Spritesheet support
      *** Single image support
      *** Automated/caching mask support

    ** Animation, e.g., Walkabout, Weapon

      *** Eventually remove pyganim as dependency, make a better animation object more suited to the operations of Hypatia Engine
      *** Support for animations using spritesheets
      *** Automated/caching mask support
      *** GIF support
      *** Animation anchoring (anchor one animation to another); pin an animation to another based on unique color values, e.g., a unique red pixel on a hat animation is afixed to the position of the same color which is similarly only present in one pixel per frame of the walkabout animation.

  * Entities

    ** frame-independent movement, esp. utilizing physics libraries
    ** Players: basic interplayer support, inc., human and NPC
    ** easy-to-access current_surface() for blitting
    ** absolute positional data

  * Quests and Narrative

    ** Dialogs, interactive dialogs and menus

  * Stats

    ** Usage-based item stats; experience_triggers, ability_experience_requirements
    ** *note:* plans for the hypatia game engine do not include conventional RPG stats for the player, only item proficiency stats.

  * Inventory
  * Save & Load
  * Tilemaps

    ** Support for Tiled editor
    ** Door editor/portal management
    ** Static decal support
    ** Compile each layer as single surface
    ** Store data/tiles in easily managed dictionaries which exist in a list to represent layers and their tiles.

      *** Key: (x, y)
      *** Value: Tile()

    ** Layer support

      ** Efficiently compile each layer of tiles to a respective image
      ** Alpha transparency

    ** Tile which references tilesheet area, but holds no actual image
    ** Tilesheet support
    ** Create from string
    ** Animated tile support
    ** Our own map editor, akin to OHRRPGCE
    ** Save, load
    ** Live updates and changes
    ** wallmap index: cache impassability data from each tile therein the list of dictionaries which represent layers and their tiles (x, y) as key; see "store data/tiles in easily managed dictionaries"

  * Combat
  * Entities

    ** Human player
    ** NPC

  * Triggers
  * Cutscenes
  * State Management (State Stack)

    ** World map state:
    ** Local map state:
    ** Menu state:

  * Examples; many quality examples for different kinds of games
  * Excellent documentation

    ** api docs
    ** docs for the GUI tools
    ** articles or blog-type with various usage examples, how-tos, etc.
    ** Walkthroughs. Especially video.
    ** Tons of videos and screencasts, webms, videos, etc.
    ** Tons of pictures.
    ** Instructions for the designer/easy instructions for sprites and such.
    ** Amazing, consistent docstrings
    ** Wiki should centralize all this info and media

=== These items need to be sorted to the above megalist:

  * destructible environments, entities, everything
  * installer; should come many forms, any type of installation should be very easy
  * code cleanup, optimization
  * unit testing
  * Algorithms, generic data:

    ** A*
    ** BSP

  * Render * effects

    * surface/screen distortions
    * set tilemap "background" (voids nodraw)

  * Procedural generation

    ** walkabout sprite generation from starting character info and playtime, other factors
    ** map generation: flow maps, binary space partitions, etc
    ** foe generation, foe behavior generation

  * tiles

    ** paralax
    ** 3D blueprint_from_string support
    ** set player pos
    ** cycle_palette added as tile_property; example is water tile; see swatch.ini
    ** AnimatedTile, with effects support, e.g., shift_pallete; reflect changes in Walkabout
    ** Fuller implementation/configuration of the anchor/Walkabout child system. test/debug with animated children. make animated hat/helmet?
    ** updated tilemap collision system
    ** all TileProperties have pixel position set in rect. ALL. See comments in tiles.py.
    ** updated tilemap collision system; made more usable; has property now of impassable

  * entities

    ** generic npc
    ** pushable attribute

= Architecture

== Introduction

[quote,'http://www.bitformation.com/art/sample_sw_design_doc.html[bitInformation Consulting - Sample Software Design Document]']
____
Should contain details such as:

  * The type of the system (distributed, client-server, etc.)
  * What platform(s) the system will run on
  * The major inputs and outputs
  * What user interfaces the system will have and in what form (web, Windows GUI, etc.)
  * The distances between components - on different PCs, on a LAN, on the web
  * A rough estimate of the number of instances of each part (modules, threads, processes, clients, etc.)

A block diagram of the modules and the relationships between them can be very useful here. Try to point out the dynamic aspects even though this view is mostly static: include arrows to indicate flow of data and/or control, multiple boxes to indicate multiple instances of a thread or a module, etc. 
____

The system is client based, possibly local/no-net multiplayer support and features. If there is multiplayer, the distances between components would be the gamepad being held by the person next to you.

Hypatia Engine should run on whichever OS, with whatever version of software  PyGame can. A focus on Python 2.7.x and Python 3.x. Focus on the following operating systems, in this order:

  - FreeBSD
  - Android
  - Other Linux
  - Windows
  - Mac

== Data

[quote,'http://www.bitformation.com/art/sample_sw_design_doc.html[bitInformation Consulting - Sample Software Design Document]']
____
This section describes the persistent data, and/or any other data important enough to justify a separate section. Such a section will not be needed when there isn't a central database, or any other bulk of permanent storage. 
____

=== Introduction

[quote,'http://www.bitformation.com/art/sample_sw_design_doc.html[bitInformation Consulting - Sample Software Design Document]']
____
Should explain the need for a database, the considerations which led to the choice of a particular type of database; should contain a short description of the data stored in there, an estimate of the size and frequency of updates, some special considerations like security requirements, recovery, interfacing with external systems, report generation, etc. 
____

=== Schema

[quote,'http://www.bitformation.com/art/sample_sw_design_doc.html[bitInformation Consulting - Sample Software Design Document]']
____
Should give a list of tables and columns in each table, a description of each of the following - data type, size, number of records, what data it keeps, which parts of the software read it and why, which parts of the software write it and when, an estimate of the update frequency. 
____

=== File and Data Formats

[quote,'http://www.bitformation.com/art/sample_sw_design_doc.html[bitInformation Consulting - Sample Software Design Document]']
____
Most systems deal with external data stored in files, the majority of these notably configuration files and imported or exported data files. The files should be listed, as well as which module reads/writes them, at what instances and for what purpose. This section should give the name, or a detailed description, of the file formats. 
____

== Architectural Strategies/Code

=== Purpose

The purpose of _architectural stratagies_ is to:

  * Define any special considerations that led to specific design
  * general comments about code, notes that do not fit into any specific sub-section
  * Describe any design decisions and/or statagies that affect the overall organization of the system and its higher-level structures
  * Did any of the design requirements necessitate a particular approach?
  * UML System Use Case diagrams constituting a high-level use case view to explain or justify approach. Use only diagrams which depict significant, central functionality of the system, or that have architectural impact, such as:

    ** database
    ** communication (e.g., between components)
    ** expansions/upgrades
    ** data management; are data items being transferred between subsystems or imported into/exported from your application tagged with a format version number in case future releases of the application change the transmission format?

These are not necessarily things that you should do, but it gives an example of the type of "design decisions" that belong in this section.  Each decision should be accompanied by the reason it was taken.

=== State Management (State Stack)

You can think of a game having several states, such as a JRPG:

  * combat
  * menu
  * world map
  * local map

Said states, like _combat_, have stateful information about them, e.g., opponent, party, and background.

It's the job of the _state machine_ to use the update() method of the right _game state_. A _game state_ should have the following methods:

  * update
  * render
  * on_enter(): action to take when state is entered
  * on_exit(): action to take when state is exited

REMEMBER: duck typing! If it looks like a duck, and quack()s like a duck, it's a duck!

Managing the game state. A game loop--calling an update function every frame. And basically, what is "updated" for a frame is based on the game's state, e.g., menu, combat, world map, local map.

So the main loop needs a _state machine_ for performing a series of updates depending upon the game state (e.g., menu, world map) and handing off the new state of the game state (the new updated data) to the renderer.

==== State Stack

The game's main loop will refer to the state stack's update() method, which runs the update() method of the _game state_ instance contained in the stack array's zeroth element.

So again, a StackState is really a list with methods to add a "head" (insert item at index 0) and to "pop the head off"--to destroy the zeroth element's game state instance, thus returning us to our former game state's state.

The StateStack has the folowing methods:

  * update(): update the stack's head game state (gamestate.update())
  * pop_off_head(): delete the zeroth element, remove the zeroth element reference to a game state object
  * append_head(): add a game state at the zeroth element (pushing all the other elements down by one, we don't lose any data), this is basically list.insert(0, ...)
  * render(): render the stack's head game state (gamestate.render())

=== Modules/High Level Component View

==== Purpose

The _modules/high level component view_ has the responsibilities of:

  ** Describing the logical divisions made in the project, e.g., GUI, sprites, audio.
  ** Which design requirements go to which components or subsystems and why?
  ** Describing the purpose/role of each component. Don't use too much detail about the components themselves.
  ** describe each components inputs

    *** where it receives said inputs
    *** format the inputs are in
    *** methods used for input, e.g., read from a file, direct funtion call

  ** describe each component's outputs

    *** which outputs it produces
    *** where does output go
    *** format of output
    *** what format used for output

  ** describe what modules each module/component uses and why
  ** specify which non-trivial algorithms and data structures each module uses and why

==== Module name

A component/module.

===== Internal Functions

[quote,'http://www.bitformation.com/art/sample_sw_design_doc.html[bitInformation Consulting - Sample Software Design Document]']
____
This section should be repeated for each module description - a comprehensive listing of the module non-trivial internal functions (functions that are not part of any interface). Be sure to refer to each item mentioned below:

  * General description of the function and what it is used for.
  * The name of the function.
  * The return type.
  * Ranges of return values and their meanings.
  * Parameter names, types, whether the parameter is input, output or both and under what circumstances it is read or written.
  * Assumptions on the parameter values.
  * Assumptions on other conditions, such as global data or system state.
  * Input validations that the function performs.
  * Side effects of the function.
  * Exceptions the function might throw and under what conditions.
  * Non-trivial algorithms used.
  * Non-trivial data structures used and for what purpose.
  * Other non-trivial functions that the function calls.
  * If the software has a layer structure, or some other inner partitioning, then to which part or layer this function belongs (this information should be evident from the naming convention).
____

=== High Level Deployment View

[quote,'http://webcache.googleusercontent.com/search?q=cache:1rTEwgpQg5UJ:https://www.cs.purdue.edu/homes/cs307/ExampleDocs/DesignTemplate_Fall08.doc+&cd=2&hl=en&ct=clnk&gl=us[Perdue Design Template]']
____
Use a UML Deployment diagram to describe any logical divisions that you have made in your project for deployment (e.g. server, client).  As with all views, you should also provide a description and rationale excepted for the trivially obvious.
____

=== Interfaces

[quote,'http://www.bitformation.com/art/sample_sw_design_doc.html[bitInformation Consulting - Sample Software Design Document]']
____
Every module must expose one or more interfaces. If these interfaces are not trivial and clear from the module descriptions, they should be listed and described in an orderly fashion at this point. This description should detail the purpose of each interface and in what context it can be used. It should also mention what kind of modules or objects expose it and which ones will be using it. If using the interface requires obtaining a reference to it, there should be an explanation of how such a reference is to be obtained and what information will be needed in order to do so. Following the description of the interface, there should come a list of the interface functions, referring to the very same items mentioned above (see section 2.4.1.n Internal Functions).

It is advisable to add here a description of the scheme that will determine how the interfaces will evolve in future versions of the system in order to answer new requirements and modifications. If backward and forward compatibility is one of the requirements, explain how this scheme supports it. 
____

= Operation

[quote,'http://www.bitformation.com/art/sample_sw_design_doc.html[bitInformation Consulting - Sample Software Design Document]']
____
This section should describe issues related to how the system is supposed to operate once it has been implemented.
____

== User types

[quote,'http://www.bitformation.com/art/sample_sw_design_doc.html[bitInformation Consulting - Sample Software Design Document]']
____
Should list the various types of users that will use the system (e.g., administrators, operators, managers, employees, customers...) Should also describe the user interface each user type would need to employ, and what prior knowledge and experience each type would require. Furthermore, this section should specify for each authenticated type/user which operations they may be allowed to perform, and which parts of the system, or data, would remain closed to them. Another important clarification should be the number of users the system may support and how many of them would be able to work concurrently. 
____

== Scenarios

[quote,'http://www.bitformation.com/art/sample_sw_design_doc.html[bitInformation Consulting - Sample Software Design Document]']
____
Should describe a few typical scenarios of how the system works. For example, what happens in the system while a user logs in, gives a short sequence of typical commands and logs out - what data flows from which module to where, what triggers which actions, etc. If the system is not very simple, this description can make the difference between utterly confused and fully comprehending readers.
____

== Installation


== Licensing

[quote,'http://www.bitformation.com/art/sample_sw_design_doc.html[bitInformation Consulting - Sample Software Design Document]']
____
Most commercial software is protected by a licensing scheme. If this is the case with your system, you should describe the scheme you are going to use, particularly the way a license will be validated (by some internal consistency check, or by an online query to a central server), at what times (during installation, at program start up, at regular intervals) and what should happen when validation fails. 
____

== Upgrades

[quote,'http://www.bitformation.com/art/sample_sw_design_doc.html[bitInformation Consulting - Sample Software Design Document]']
____
This section should describe the way the system would be upgraded to newer versions. It should also relate to the following questions:

  * How will these upgrades be distributed (Internet, CD)?
  * How (if at all) will an appropriate license be distributed and verified?
  * Who will be authorized to install the upgraded version (i.e., which of the system's user types mentioned in section 3.1)?
  * How complicated will it be to reinstall the previous version in case an upgrade causes problems?
  * How can a partial upgrade be installed? (e.g., in the case of a distributed system where it is unreasonable to expect the server and all the clients to be upgraded at the same time)
  * How will the design handle version conflicts (between a server and a client, between two modules, between stored data and a module or between imported data and a module)?
  * How will the design ensure that the users do not experience data loss or downtime during an upgrade?

If time-limited ("try before you buy") or demo versions are planned, they require special attention. You must consider all possible scenarios, such as upgrading from a demo to a full version, attempting to install a demo over a full version, the coexistence of a demo and a full version on the same machine, etc. 
____

== Uninstall

[quote,'http://www.bitformation.com/art/sample_sw_design_doc.html[bitInformation Consulting - Sample Software Design Document]']
____
This section should describe the way the uninstall would be done, who would be authorized to perform it, what resources would be needed, what data would be left behind, and what would happen to that data when re-installing on a computer after an uninstall. Don't forget to consider the implications of your licensing scheme.
____

= Development

[quote,'http://www.bitformation.com/art/sample_sw_design_doc.html[bitInformation Consulting - Sample Software Design Document]']
____
[Some companies require that this chapter be included in the design; others expect this information to appear in a separate document.]

This section lays out a plan for the development process. It can be quite complex if the project has modules that cannot be developed or tested before others are completed, or if it depends on the availability of external resources like developers, machines, access to special services or real-world objects, etc.

For example, you may choose to start by developing a mock-up version of some module, in order to allow the development and testing of another. Once this is done, you can develop the two modules in parallel using two independent teams. Another common technique is to manually prepare a data file that will be used as the input to some module until the UI is mature enough to supply real data.

The design should describe the necessary resources - number of developers, their required skills, the hardware, environment and development tools required for the development process. It should also say when and for how long each resource would be needed. This is the place to include development time estimates. 
____

= Miscellanea / Appendices

== Conformance with standards

[quote,'http://www.bitformation.com/art/sample_sw_design_doc.html[bitInformation Consulting - Sample Software Design Document]']
____
Must contain the lists of both the standards the system should conform to and the references as to where these standards may be obtained. 
____

  * link:https://www.python.org/dev/peps/pep-0008/[PEP8]
  * link:http://sphinxcontrib-napoleon.readthedocs.org/en/latest/example_google.html[Google-style Docstrings]

== Interoperability with other systems

[quote,'http://www.bitformation.com/art/sample_sw_design_doc.html[bitInformation Consulting - Sample Software Design Document]']
____
Must contain the list of the external systems that the new system should interact with in addition to a description of the way in which it should do so. 
____

== Expandability

[quote,'http://www.bitformation.com/art/sample_sw_design_doc.html[bitInformation Consulting - Sample Software Design Document]']
____
If applicable, this section should explain how a third party would be able to extend the system. This may be done by writing plug-ins or scripts, or by writing some instructions in a configuration file. 
____

== Debugging

[quote,'http://www.bitformation.com/art/sample_sw_design_doc.html[bitInformation Consulting - Sample Software Design Document]']
____
Most of the development time will no doubt be spent on debugging. The larger the system, the more essential it becomes to have some built-in mechanism to help debug the complete system. It can be a mechanism of log files, or special functions in each interface, or a special mode in the UI. This section should describe your choice of mechanisms, the ways in which they would be used, and what the programmers should do in order to make their module part of the game. 
____

== Security

[quote,'http://www.bitformation.com/art/sample_sw_design_doc.html[bitInformation Consulting - Sample Software Design Document]']
____
Most software systems today face one or more security threats: spoofing, identity theft, password stealing, eavesdropping, sniffing, spamming, data theft, web site defacing, denial of service attacks, password breaking, fraud, forgery, hacking, viruses, worms, trojans - just to name a few.

This section should describe the security threats you foresee and intend to deal with. It should specify your assumptions regarding the environment (whether the computer is behind a firewall, who has physical access to it, etc.) and the means you plan to employ in order to protect the system (authentication, data encryption, input validation, internal sanity checks), etc. 
____

== Open Issues

[quote,'http://www.bitformation.com/art/sample_sw_design_doc.html[bitInformation Consulting - Sample Software Design Document]']
____
There are always some issues left open. Sometimes information needed for making certain design decisions is not available in time or even at all. Sometimes decisions are delayed for a more convenient time. This section should list all the open issues in the design, and, if possible, point out what is required in order to resolve each one.
____

== Glossary

[quote,'http://www.bitformation.com/art/sample_sw_design_doc.html[bitInformation Consulting - Sample Software Design Document]']
____
List all the technical terms, concepts and acronyms that appear in the document or that are relevant to it, for the sake of the uninformed reader. The explanation of each term/concept/acronym should not exceed 4 lines. People will thank you for not having to spend hours on looking up unfamiliar terminology.
____

Some aspects and terminology are borrowed from link:http://rpg.hamsterrepublic.com/ohrrpgce/Main_Page[OHRRPGCE].

Walkabout::
  A walkabout is a series of pictures (sprites) used for entities which can _walk about_ the map, e.g., heroes, NPCs. It specifically refers to pictures which illustrate an entity facing different directions, or performating actions in any of said directions.
NPC::
  A player that isn't representing the/a human.
Entity::
  An "entity" is, in high concept, an object which is capable of state changes to itself or the game. Such as an NPC, the player, a sign (a sign changes the game state to display a message upon activation, e.g., Sign.display_message()). These things almost always have graphics representing either its state or being.
Tilesheet, Tilemap::
  A series of images coalesced into a single image, whereas each image's area/index is determinable by an (x, y) constant referencing the tile size constituting each image.

== Bibliography

[quote,'http://www.bitformation.com/art/sample_sw_design_doc.html[bitInformation Consulting - Sample Software Design Document]']
____
If applicable, list documents, publications, books and other information sources that your readers may find useful when trying to understand the full implications of your design. 
____

  * link:http://gamedevelopment.tutsplus.com/articles/how-to-build-a-jrpg-a-primer-for-game-developers--gamedev-6676[How to Build a JRPG: A Primer for Game Developers]
  * link:http://www.reddit.com/r/Python/comments/2ak14j/made_my_first_android_app_in_under_5_hours_using/civxp7c[A reddit post about Pygame for Android]

These items were of specific aid to the concept of this document:

  * link:http://www.bitformation.com/art/sample_sw_design_doc.html[Sample Software Design Doc (High Level)]
  * link:http://www.atilim.edu.tr/~dmishra/se112/sdd_template.pdf[Software Design Document (SDD) Template]
  * link:http://en.wikipedia.org/wiki/Software_design_document[Software Design Document - Wikipedia]
  * link:http://en.wikipedia.org/wiki/Game_design_document[Game Design Document - Wikipedia]
  * link:http://webcache.googleusercontent.com/search?q=cache:1rTEwgpQg5UJ:https://www.cs.purdue.edu/homes/cs307/ExampleDocs/DesignTemplate_Fall08.doc+&cd=2&hl=en&ct=clnk&gl=us[Perdue University Design Template]

